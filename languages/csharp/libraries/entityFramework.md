# Entity Framework

## Code first

### Ensuring a db created on startup
- [ref](http://www.binaryintellect.net/articles/87446533-54b3-41ad-bea9-994091686a55.aspx)
```cs
public void Configure(IApplicationBuilder app, IWebHostEnvironment env, AppDbContext db)
{
    // ...

    db.Database.EnsureCreated();

    // ...
}
```

### Migration
```bash
dotnet ef database update last_migration_name --startup-project your_database_project --verbose
dotnet ef migrations remove --startup-project your_database_project
dotnet ef migrations add new_migration_name --startup-project your_database_project
dotnet ef database update --startup-project your_database_project --verbose
```

### Issue with migration script generation

Due to an issue in the ef-core cli tool, the --idempotent flag forces the IF statement making the changes idempotent cannot have a batch inside it. This is normally fine but for ALTER FUNCTION statements that need to be in their own batch, this causes an issue. The solution is to put the in a dynamic sql query.

Fails
```cs
protected override void Up(MigrationBuilder migrationBuilder)
{
    var sp = @"
        ALTER FUNCTION [dbo].[thing]
        (
            @ContactID INT = NULL,
            @OperationID INT = NULL
        )
        ...
        ";

    migrationBuilder.Sql(sp);
}
```

Works
```cs
protected override void Up(MigrationBuilder migrationBuilder)
{
    var sp = @"
        DECLARE @Sql NVARCHAR(MAX)
        SET @Sql = '
        ALTER FUNCTION [dbo].[thing]
        (
            @ContactID INT = NULL,
            @OperationID INT = NULL
        )
        ...'
        EXEC(@Sql)
        ";

    migrationBuilder.Sql(sp);
}
```

### SQLite issue
- put this in the context class to avoid errors with the date format for `SQLite`
    - `SQLite` is handy when you want to use it for in memory unit testing
    ```cs
    if (Database.ProviderName == "Microsoft.EntityFrameworkCore.Sqlite")
    {
        modelBuilder.Entity<EntityWithDateTimeOffsetProperty>()
            .Property(v => v.CreatedAt)
            .HasConversion(new DateTimeOffsetToBinaryConverter());
    }
    ```
    or more generically
    ```cs
    if (Database.ProviderName == "Microsoft.EntityFrameworkCore.Sqlite")
    {
        foreach (var entityType in modelBuilder.Model.GetEntityTypes())
        {
            var properties = entityType.ClrType.GetProperties()
                .Where(p => p.PropertyType == typeof(DateTimeOffset)
                            || p.PropertyType == typeof(DateTimeOffset?));

            foreach (var property in properties)
            {
                modelBuilder
                    .Entity(entityType.Name)
                    .Property(property.Name)
                    .HasConversion(new DateTimeOffsetToBinaryConverter());
            }
        }
    }
    ```

## DB first
```PowerShell
Scaffold-DbContext "Data Source=your_db_server_host_name; Integrated Security=True;MultipleActiveResultSets=True; Initial Catalog=your_db" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Tables "Table1","Table2" -f
```
- `-f` is for overriding existing class files generated previously


## Handling migrations
- [there are many ways to create migrations](https://www.thereformedprogrammer.net/handling-entity-framework-core-database-migrations-in-production-part-1/#1a-standard-ef-core-c-migration-script) each has tradeoffs
- [there are many ways to apply migrations](https://www.thereformedprogrammer.net/handling-entity-framework-core-database-migrations-in-production-part-2/) each has tradeoffs
  - having an app apply migrations typically means it needs more permissions than it should normally have
  - running EF Core migrations means you need to install the dotnet SDK on the server that runs the migration
  - running additional sql scripts on top of the ones generated by EF Core is tricky as EF Core can get mad

## `context.Database.Migrate()`
- can be called to create *and* apply all migrations to a database

## `context.Database.EnsureCreated()`
- does nothing if the db exists
- creates the database with schema if not created
- does not apply migrations and any migrations applied after this is called won't work

## Change tracking
- if you, say, have an autogenerating id field, the model instance you create will automatically have that change applied to it, so no need to query the db again
    ```cs
    
    var thing = new Thing(); // thing.Id won't be populated

    await _db.Things.AddAsync(thing, cancellationToken);
    await _db.SaveChangesAsync(cancellationToken);

    var newId = thing.Id; // this will have the Id created by the db automatically populated into it
    ```
- if changes are made to the db outside of the context you are working in, you need to recreate that context to get the fresh changes
  - you can do this by re-resolving the db context with the DI container
  - this is important for int testing something like a web api

## DbContext
- configuring entities
  - this can be done in `OnModelCreating`, but can be broken out into separate files by creating an `IEntityTypeConfiguration<TheModelType>` implementation
    ```cs
    internal class ThingConfig : IEntityTypeConfiguration<Thing>
    {
        public void Configure(EntityTypeBuilder<Thing> builder)
            => builder
                .HasIndex(a => a.Name)
                .IsUnique();
    }
    ```
  - then you need to hook this up with `OnModelCreating`
    ```cs
    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.ApplyConfiguration(new ThingConfig());
    }
    ```

- binding all entity type configurations automatically from the assembly
    ```cs
    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.ApplyConfigurationsFromAssembly(GetType().Assembly);
    }
    ```
- conditionally applying seed data
  - the recommended way this seems to be done is `OnModelCreating`
    - doing it this way means that this will only run if you call `db.Database.Migrate()` or don't have a migrated db when you run `db.Database.EnsureCreated()`
    - you may need to delete docker volumes if you are using a docker container for your db
  - you can inject `IOptions<YourConfig>` into `DbContext` to get this value
    ```cs
    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        if (_config.Value.UseSeedData)
        {
            builder.AddSeedData();
        }
    }

